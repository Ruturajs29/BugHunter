ID,Explanation,Context,Code,Correct Code
16,"Use only the VTT mode for editing vectors when rdi.smartVec().label().copyLabel() is
used for the label",mode for editing vectors at runtime,"rdi.smartVec().vecEditMode(TA::VECD);

RDI_BEGIN();
rdi.smartVec()
    .label(""sLabel"").copyLabel(false).pin(A)
    .writeData(""rt"", 8, 0)
    .execute();

rdi.smartVec()
    .label(""sLabel"").copyLabel(false).pin(A)
    .writeData(""rt"", 8, 8)
    .execute(); // 
RDI_END();","rdi.smartVec().vecEditMode(TA::VTT);

RDI_BEGIN();
rdi.smartVec()
    .label(""sLabel"").copyLabel(false).pin(A)
    .writeData(""rt"", 8, 0)
    .execute();

rdi.smartVec()
    .label(""sLabel"").copyLabel(false).pin(A)
    .writeData(""rt"", 8, 8)
    .execute(); // 
RDI_END();"
32,BUG : Port name & pin config mismatch instead of execute it will burst twice,"rdi.port(TA::MULTI_PORT).func()
This function allows multi-port labels to be combined to form a new burst. It is used for
dynamic mode in the func() class only.Multi-port burst with .port(TA::MULTI_PORT)","RDI_BEGIN();
rdi.port(""pt1"").dc().pin(""dig2"").vForce(1 uA).burst();
rdi.port(TA::MULTI_PORT).func().burst(""MPBurst2"").burst(); // n
rdi.port(""pt2"").digCap().pin(""dig1"").samples(8).execute();
rdi.port(TA::MULTI_PORT).func().burst(""MPBurst1"").burst();
RDI_END();","RDI_BEGIN();
rdi.port(""pt1"").dc().pin(""dig"").vForce(1 V).execute();
rdi.port(TA::MULTI_PORT).func().burst(""MPBurst1"").execute(); // n
rdi.port(""pt2"").digCap().pin(""dig2"").samples(8).execute();
RDI_END();"
25,"BUG : Replacing the lifecycle order 
and calling RDI_END before RDI_BEGIN inverts 
the intended session/transaction scope and 
will typically cause runtime failures or no-ops.","rdi.protocol().write()
Writes a piece of data on a specified address at runtime","ARRAY_I write_data(2); // Define a variable for a dual-site test
write_data[0]=0x1;
write_data[1]=0x2;
rdi.runTimeVal(""data"",write_data); // Site data array
RDI_END();
rdi.protocol().pname(""i2c"").write(0x4,""data"").execute();
RDI_BEGIN();","ARRAY_I write_data(2);
write_data[0]=0x1;
write_data[1]=0x2;
rdi.runTimeVal(""data"",write_data); // Site data array
RDI_BEGIN();
rdi.protocol().pname(""i2c"").write(0x4,""data"").execute();
RDI_END();"
10,changed the function names,"Reads the actual measured humidity of the selected PMUX card from the hardware and
stores it into a software cache.","RDI_BEGIN();
rdi.pmux(4).module(""02"").readHumanSeniority().execute();
RDI_END();
int hum = rdi.id(4).getHumanSeniority(""02"");","RDI_BEGIN();
rdi.pmux(4).module(""02"").readHumSensor().execute();
RDI_END();
int hum = rdi.id(4).getHumSensor (""02"");"
26,"Measurement binding/order bug on Pin2.
Specifics: iMeas() is applied immediately after the first group (waveform + repeat), before the additional groups are appended then instead of execute it will read().","rdi.dc().addWaveform()
Adds one or more waveforms in an execute() operation.
This function supports digital cards and DC Scale cards (PMU and DPS operating
modes).","anaWaveform wav1(""wav1""), wav2(""wav2""), wav3(""wav3"");
RDI_BEGIN();
rdi.dc().pin(""Pin1"").vForce().waveform(wav1)
  .addWaveform(wav2)
  .addWaveform(wav3, 2)      // Add ""wav3"" twice
  .FS(250 /* kHz */).execute();
rdi.dc().pin(""Pin2"").vForce().waveform(wav1).repeat(2)
  .iMeas()                   
  .addWaveform(wav2, 3)      // Add ""wav2"" three times (group 2..4)
  .FS(250 /* kHz */).read();
RDI_END();","anaWaveform wav1(""wav1""), wav2(""wav2""), wav3(""wav3"");
RDI_BEGIN();
 rdi.dc().pin(""Pin1"").vForce().waveform(wav1)
 .addWaveform(wav2).addWaveform(wav3,2) // Add ""wav2"" once and
 .FS(250 kHz).execute();
 rdi.dc().pin(""Pin2"").vForce().waveform (wav1).repeat(2)
 .addWaveform(wav2,3).iMeas() // Add ""wav2"" three times and me
 .FS(250 kHz).execute();
RDI_END();"
23,the order of function calling is smartVec().burstUpload(), burstUpload will help to reduce the result uploading time. The results of multiple smartVec read commands,"// You can get a combined result of all readBit()/readData() inside
ON_FIRST_INVOCATION_BEGIN();

rdi.smartVec().readMode(TA::EMAP); // TA::DIGCAP

RDI_BEGIN();
rdi.smartVec(""id"").burstUpload().begin();

rdi.smartVec(id1)
    .pin(""DATA2"").readBit(2, 2)
    .execute();

rdi.smartVec(id2)
    .pin(""DATA2"").readBit(4, 4)
    .execute();

rdi.smartVec(id3)
    .pin(""DATA4"").readData(8, 8)
    .execute();

rdi.smartVec(id4)
    .pin(""DATA4"").readData(8, 12)
    .execute();

rdi.burstUpload.smartVec().end();
RDI_END();

ON_FIRST_INVOCATION_END();

ARRAY_I bitResult = rdi.id(""id"").getReadBit(""DATA2"");
ARRAY_LL dataResult = rdi.id(""id"").getReadData(""DATA4"");","// You can get a combined result of all readBit()/readData() inside
ON_FIRST_INVOCATION_BEGIN();

rdi.smartVec().readMode(TA::EMAP); // TA::DIGCAP

RDI_BEGIN();
rdi.smartVec(""id"").burstUpload().begin();

rdi.smartVec(id1)
    .pin(""DATA2"").readBit(2, 2)
    .execute();

rdi.smartVec(id2)
    .pin(""DATA2"").readBit(4, 4)
    .execute();

rdi.smartVec(id3)
    .pin(""DATA4"").readData(8, 8)
    .execute();

rdi.smartVec(id4)
    .pin(""DATA4"").readData(8, 12)
    .execute();

rdi.smartVec().burstUpload().end();
RDI_END();

ON_FIRST_INVOCATION_END();

ARRAY_I bitResult = rdi.id(""id"").getReadBit(""DATA2"");
ARRAY_LL dataResult = rdi.id(""id"").getReadData(""DATA4"");"
4,iClamp low and high values are exchanged,method order of arguments,"rdi.alarm().pin(m_rMcd.sP_VS).enable(true);        //turn on VS alarm
            //go back to default voltage
            rdi.dc().pin(m_rMcd.sP_VS).vForce(31 V).vForceRange(30 V).iForceRange(50 mA).iClamp(50 mA, -50 mA)
                    .pin(m_rMcd.sP_LIN).vForce(13.5 V).vForceRange(30 V).iForceRange(5 uA).iClamp(-5 uA, 5 uA)
                    .execute();
            rdi.wait(1 ms);","rdi.alarm().pin(m_rMcd.sP_VS).enable(true);        //turn on VS alarm
            //go back to default voltage
            rdi.dc().pin(m_rMcd.sP_VS).vForce(31 V).vForceRange(30 V).iForceRange(50 mA).iClamp(-50 mA, 50 mA)
                    .pin(m_rMcd.sP_LIN).vForce(13.5 V).vForceRange(30 V).iForceRange(5 uA).iClamp(-5 uA, 5 uA)
                    .execute();
            rdi.wait(1 ms);"
31,"BUG : Logical api changes (push_forward >> push_back , port name at intaialization is different from runTimeVAL & synatax of id changed to idd )","rdi.func().burstRunTime()
Creates an empty burst label and specifies the maximum number of labels to be
patched.
SmartRDI uses this function to generate an empty burst label and then applies the
firmware command SQPG to patch the burst content","vector<string> vec_port1;
vec_port1.burst();
vec_port1.push_back(""label3"");
vec_port2.push_back(""label7"");
vec_port1.push_forward(""label25"");
vec_port2.push_forward(""label31"");
rdi.runTimeVal(""rt"",vec_port2); // The label to be patched into the
RDI_BEGIN();
rdi.port(""A"").func(""idd"").burstRunTime(""rt"",200).execute();
RDI_END();
ARRAY_I ary = rdi.id(""idd"").getMultiPassFail();","vector<string> vec_port1;
vec_port1.clear();
vec_port1.push_back(""label3"");
vec_port1.push_back(""label7"");
vec_port1.push_back(""label25"");
vec_port1.push_back(""label31"");
rdi.runTimeVal(""rt"",vec_port1); // The label to be patched into the
RDI_BEGIN();
rdi.port(""A"").func(""id"").burstRunTime(""rt"",200).execute();
RDI_END();
ARRAY_I ary = rdi.id(""id"").getMultiPassFail();"
17,to get first filed vector the function used is getFFV(),getting the first fail vector.,"RDI_BEGIN();
rdi.emap(""a"")
    .label(""label2"").pin(""pB"")
    .FFV(10)
    .execute();
RDI_END();

int iffv = rdi.id(""a"").getFFC();","RDI_BEGIN();
rdi.emap(""a"")
    .label(""label2"").pin(""pB"")
    .FFV(10)
    .execute();
RDI_END();

int iffv = rdi.id(""a"").getFFV();"
27,"BUGS:
- Pin list changed to ""DPS_0,DPS_1"" (mismatch with configured pins)
- Method name changed to ""imeas()"" (incorrect casing/API)
- Operation changed from ""execute()"" to ""write()"" (wrong semantics in DC measurement chain)","rdi.dc().iMeasRange()
Specifies a current measurement range.SmartRDI will check the time between iMeasRange() and the next event on the pin. ","RDI_BEGIN();
rdi.dc().pin(""DPS_1,DPS_2"").imeasRange(100 uA);
rdi.dc().pin(""DPS_1,DPS_2"").vForce(0.01 V);
rdi.wait(3 ms);
rdi.dc(""im1"").pin(""DPS_0,DPS_1"").imeas().write();
RDI_END();","RDI_BEGIN();
rdi.dc().pin(""DPS_1,DPS_2"").iMeasRange(100 uA);
rdi.dc().pin(""DPS_1,DPS_2"").vForce(0.01 V);
rdi.wait(3 ms);
rdi.dc(""im1"").pin(""DPS_1,DPS_2"").iMeas().execute();
RDI_END();"
